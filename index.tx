// Note to self - in this process we can assume that
// the shape that we are using is *valid* an hence
// and has been validated upon input by on2ts 

// Note that the *merge* algorithm can be used to simplify the
// shape *however* it is not appropriate to inforporate any of
// that algorithm here.


// Note to self it looks like dash just simplifies some SHACL expressions

// Logical constraints in properties http://datashapes.org/forms.html#multi

// Consider making nested shapes in <iframe> to get around html issues

// Use dash:reifiableBy


// TODO: Look into https://github.com/Draggable/formeo/blob/master/src/js/components/fields/edit-panel.js




// TOTALLY UNRELATED http://jens-lehmann.org/files/2018/grades_litmus.pdf
// https://github.com/LITMUS-Benchmark-Suite/sparql-to-gremlin/blob/master/src/main/java/com/datastax/sparql/gremlin/TraversalBuilder.java




import { useEffect, useReducer, useState } from "react"
import { sortBy } from "ramda"
import { mockShape2 } from './test/unit/basic-on2ts-mock'
import { } from "immutable"

// TODO: Make SHACL logic simplifier that implements de-morgans laws
// TODO MAKE SURE WE DON'T RENDER ANYTHING THAT IS DEACTIVATED
// TODO: Add rdf:langString dropdown



// http://datashapes.org/forms.html#AutoCompleteEditor
// http://datashapes.org/suggestions.html


// Logical constraint handling (node) [implement once we are able to mock lists]
// This can also be used to handle xone; for and just display them all since they all
// need to be valid anyway
export function OrHandler({or}: any) {
  return (
    <>
    <select name="cars" id="cars">
      <option value="volvo">{'\u274c\tMercedes'}</option>
      <option value="saab">{'\u2714\tMazda'}</option>
      <option value="mercedes">{'\u274c\tLoremIpsum'}</option>
      <option value="audi">{'\u274c  V'}</option>
    </select>
    </>
  )
}

// And handlers (for node)
export function AndHandler({and}: any) {
  // And is a rdf:list
  for (const shape of and.list) {

  }
}

// This should be hidden *unless* it provides
// a validation
export function NotHandler() {

}

// TODO: Handle extraction of NameGroup properly in on2ts
// TODO: Have 2 UI boxes to display the validation progress
// 1 for the sync validation (not dependent on other data)
// and 1 for async (dependent on other data and revalidates after each validation)

// Add UI to indicate connecton to each of the data stores

/**
 * This function accepts an LDflex object, attempts to load
 * it from the server and validates that the shape is valid
 * 
 * If the shape is valid it will be saved to memory and `ToShaclForm`
 * will be called.
 * 
 * If the shape is *not* valid a popup is created that alerts
 * users of the errors and prompts them to resolve the error
 * TODO: Workout what the right options for ^^ are
 * @param param0 
 */
export function LDflexObjToForm({shacl}: any): void {
  
}

// TODO: Types
/**
 * Node that this is *not* an LDflex/Rdf/on2ts object
 * - it is an object created by the Shacl form generator
 * that inverts the order of control for this particular operation
 * @param param0 
 */
export function ToGroupField({group}: any) {
  //TODO:remove optional chaining
  console.log(group);
  // @ts-ignore
  const sortedProperties = sortBy( item => item?.order?.value ?? 0, group.property)
  return (
    // <>hi</>
    <>
    <br/>
      {/* <label htmlFor={group.value}>{group.group.label?.value ?? group.group.name?.value ?? 'fieldset'}</label> */}
      <fieldset id={group.value} title={group.group.label?.value ?? group.group.name?.value ?? 'fieldset'} name={'label'}>
      <legend>{group.group.label?.value ?? group.group.name?.value ?? 'fieldset'}</legend>
      {sortedProperties.map(property => <ToPropertyField property={property}/>)}
    </fieldset>
    <br/>
    </>
  )
};

export function ToPropertyField({property}: any) {
  const [hidden, setHidden] = useState(false)
  const [over, setOver] = useState(false)
  console.log('propet',property);
  // TODO: Double check divs here
  return (
    <>
    <div
    style={{ height: hidden ? '0px' : 'auto', overflow: 'hidden'}}
    >

    
    <div
      // To allow the field to be picked up 
      onDragEndCapture={(e) => {console.log('on drag end capture', property.name?.value ?? property?.label?.value, e)}}
      draggable={true}
      onDragStart={() => {
        setHidden(true)
      }}
      onDragEnd={() => {
        setHidden(false)
      }}
      onDrop={() => {console.log('drop')}}
      onDragEnter={() => {setOver(true)}}
      onDragExit={() => {setOver(false)}}
      style={{ padding: over ? '20px' : '0px'}}
      // onDragOver={() => {console.log('dragging over')}}
    >
      <label htmlFor={property.value}>{property.name?.value ?? property?.label?.value}</label>
      <input id={property.value} name={property.value} readOnly={false} required={true} placeholder={property.name?.value ?? property?.label?.value}/>
      <br/>
    </div>
    </div>
    </>
  )
};

/**
 * 
 */
export function FlattenElement(constraint) {

}




// TODO: Make SHACL aware of 'flattening'
// Takes a nodeshape *or* propertyshape and flattens
// the logical components for the purpose of displaying
export function flattenShape(shape) {
  if (
    // When we add inferencing to on2ts this can become
    // shape instanceof PropertyShape
    shape.path !== undefined // Existance of path property is heuristic that it is a property shape
    ) {
      return {
        properties: [shape],
        or: [],
        xone: []
      }
    }
  else {
    let properties = shape.property.toArray();
    let or = shape.or.toArray();
    let xone = shape.xone.toArray();
    for (const n of shape.and) {
      for (const ns of n.list) {
        const flattened = flattenShape(ns)
        properties = [ ...properties, ...flattened.properties ]
        // the 'or' components can be arbitrar
        or = [ ...or, ...flattened.or ]
        xone = [ ...xone, ...flattened.xone ]
        // Perhaps this does not need to be a loop
        // as we can only have one and constraint component
        // in a SHACL constraint
  
        // NOTE: As far as I can tell - the elements in and/or shapes can be node shapes
        // *or* property shapes        
      }
    }
    // const properties = node.property.toArray();
  }
}

enum LogicalStatementType {
  and,
  or,
  xone,
  not,
  statement,
  empty,
};


// In the case of Schimatos a node shape or property shape
// always originates at an and statement
interface AndStatement<T> {
  type: LogicalStatementType.and,
  statement: LogicalStatement<T>[],
}

interface OrStatement<T> {
  type: LogicalStatementType.or,
  statement: LogicalStatement<T>[],
}

interface XoneStatement<T> {
  type: LogicalStatementType.xone,
  statement: LogicalStatement<T>[],
}

interface NotStatement<T> {
  type: LogicalStatementType.not,
  statement: LogicalStatement<T>,
}

/**
 * Either always true or always false
 */
interface EmptyStatement {
  type: LogicalStatementType.empty,
  statement: boolean,
}


interface Statment<T> {
  type: LogicalStatementType.statement,
  statement: T
}

type LogicalStatement<T> = AndStatement<T> | OrStatement<T> | XoneStatement<T> | NotStatement<T> | Statment<T> | EmptyStatement;

function simplifyStatement<T>(statement: LogicalStatement<T>): LogicalStatement<T> {
  switch(statement.type) {
    case LogicalStatementType.and:  return simplifyAnd(statement)
    case LogicalStatementType.or:   return simplifyOr(statement)
    case LogicalStatementType.xone: return simplifyXone(statement)
    case LogicalStatementType.not:  return simplifyNot(statement)
    default:                       return statement
  }
}

function separateLogicList<T>(statements: LogicalStatement<T>[], breakEmpty?: boolean) {
  let and: AndStatement<T>[] = []
  let xone: XoneStatement<T>[] = []
  let or: OrStatement<T>[] = []
  let not: NotStatement<T>[] = []
  let empty: EmptyStatement[] = []
  let statement: Statment<T>[] = []
  for (const st of statements) {
    const simplified = simplifyStatement(st)
    switch(simplified.type) {
      case LogicalStatementType.and:
        and.push(simplified);
        break;
      case LogicalStatementType.or:   
        or.push(simplified)
        break;
      case LogicalStatementType.xone: 
        xone.push(simplified)
        break;
      case LogicalStatementType.not:  
        not.push(simplified)
        break;
      case LogicalStatementType.statement:
        statement.push(simplified)
        break;
      case LogicalStatementType.empty:
        if (breakEmpty !== undefined && breakEmpty === simplified.statement) {
          return;
        }
        empty.push(simplified)
    }
  }
  return {
    and,
    xone,
    or,
    not,
    empty,
    statement,
  }
}

function simplifyAnd<T>(statement: AndStatement<T>): LogicalStatement<T>  {
  // If empty it holds true arbitrarily
  if (statement.statement.length === 0) {
    return { type: LogicalStatementType.empty, statement: true }
  // If it is of length 1, it depends only on the internal statement
  } else if (statement.statement.length === 1) {
    return statement.statement[0]
  }
  
  const separated = separateLogicList(statement.statement, false)
  

  
  
  
  
  let and: LogicalStatement<T>[] = []
  let xone: LogicalStatement<T>[] = []
  let or: LogicalStatement<T>[] = []
  let not: LogicalStatement<T>[] = []

  for (const element of statement.statement) {
    
    const simplified = simplifyStatement(element)

    if (simplified.type === LogicalStatementType.and) {
      // Simplifying nested and
      and = [ ...and, ...simplified.statement ]
    } else if (simplified.type === LogicalStatementType.empty) {
      // In this case the and statement is *always* false
      if (simplified.statement === false) {
        return { type: LogicalStatementType.empty, statement: false }
      }
      // Otherwise it adds no meaning so we can skip handling the case
      // where simplified.statement === true

    } else if (simplified.statement === LogicalStatementType.or) {
      
    }

  }

  return {
    type: LogicalStatementType.and,
    statement: and
  }
}





function simplify(statement: LogicalStatement) {
  let and = []
  let or = []
  let xone = []
  let not = []

  for (const expression of statement.and) {
    and = [ and, ...expression.and ] // Commutativity of and
    or = 
  }

  return {
    and,
    or,
    xone,
    not
  }
}



/**
 * Simplifies (flattens) a shape that uses
 * arbitrary logic
 * @param shape 
 */
function logicHandler(shape) {
  let {
    statements,
    and,
    or,
    xone,
    not
  } = getStatements(shape)

  for (const statement of not) {
    const handled = logicHandler(statement)

  }

  for (const statement of or) {
    for (const atom of statement) {
      const handled = logicHandler(atom)
      or = [ or, ...handled.or ] // Nested ors are meaningless

    }
  }

  for (const statement of and) {
    // TODO: See if anything needs to be nested here
    for (const atom of statement) {
      const handled = logicHandler(statement)
      statements = [ ...statements, handled.statements ]
      or = [ ...or, handled.or ]
      xone = [ ...xone, handled.xone ]
      not = [ ...not, handled.not ]
    }
  }
  and = []


  return {
    statements,
    or,
    xone,
    not
  }
}

/**
 * Breaks down property shape
 */
function getStatements() {
  return {
    statements: [],
    and: [],
    or: [],
    xone: [],
    not: []
  }
}

/**
 * For the sake of Schimatos there is no difference
 * between using sh:and, and having all the statements
 * listed together - this is because sh:and is really
 * only a convenience item for combining shapes that are
 * *stored* separately. For display/validation it does not matter
 * @param node 
 */
function andHandler(node) {
  



  let statements = []
  let andStatements = [] // List of lists
  let orStatements = []  // List of lists
  let notStatements = [] // List of lists
}




export function flattenNodeShape(node) {
  // TODO: Discuss best handling of sh:order/sh:group when using logical constriants
  // at this stage we just flatten the thing
  
  // x.r$property

  const properties = node.property.toArray();
  const orConstraints = node.or.toArray();
  
  // Perhaps this does not need to be a loop
  // as we can only have one and constraint component
  // in a SHACL constraint
  for (const n of node.and) {
    for (const ns of n.list) {
      const flattened = flattenNodeShape(ns)
      // NOTE: As far as I can tell - the elements in and/or shapes can be node shapes
      // *or* property shapes
    }
  }



}

// TODO: Do live shacl-sparql validation (there are cases)
// where nothing needs to be sent to the sparql endpoint
// e.g. 5.1 An Example SPARQL-based Constraint in spec

// TODO: Handle cases where sh:path is not specified -
// for instance in the case of qualified value shapes.

// Note - qualified value shapes are largely there for
// the sake of validation *however* it worth noting that
// 
export function qualifiedValueShapeHandler() {

}


// TODO: Make GUI to select sparql 'endpoint' that could be a file etc.
// and checks access to source before allowing selection


/**
 * Generates a SHACL form from a nodeshape
 * represented as an LDflex object
 * @param obj LDflex nodeshape object
 */
export function ToShaclForm({shacl, nameToUse}: any) {
  /**
   * First we need to group the properties and
   * enforce any ordering constraints.
   */
  
   // Does using useEffect reduce the amount of computation?
  // I'm thinking no bc in theory this render should only be
  // called once but I will keep this here as a node for now
  // TODO: ADD TYPES HERE 
  let group = {};
  let properties = [];
  
  for (const property of mockShape2.property) {
    // TODO: Remove this once we have types working correctly
    // @ts-ignore
    if ('group' in property) {
      // TODO: Remove this once types are resolved
      console.log(property, group);
      console.log('y' in group);
      console.log(`${property.group.value}` in group);
      // @ts-ignore 
      if (`${property.group.value}` in group) {
        // @ts-ignore
        group[property.group.value].property.push(property);
      } else {
        // @ts-ignore
        group[property.group.value] = {
          group: property.group,
          property: [property]
        }
      }
    } else {
      properties.push(property);
    }
  }
  // TODO: Remove optional chaining
  // TODO: See if the SHACL SHACL enforces a default value
  // @ts-ignore 
  const sorted = sortBy( item => item?.order?.value ?? 0, [ ...properties, ...Object.values(group) ] )

  console.log('sorted', sorted)
  const id = Math.random()

  // const a = document.forms['form' + id]?.getElementsByTagName('input').length
  // console.log(document.forms)
  //  {mockShape2.property.map((x: any) => x.toString())}
  // Be careful with what we are using to to the turnary check here
  return (
    <form name={nameToUse}>  
      <OrHandler />
      {sorted.map((x: any) => x.group ? <ToGroupField group={x} /> : <ToPropertyField property={x} />)} 
    </form>
  )
}




// export function ToPropertyField({property}: any) {

// }

// TODO: Investigate this further - fixing the typescript proxy handler
// interface ProxyConstructor {
//   revocable<T extends object>(target: T, handler: ProxyHandler<T>): { proxy: T; revoke: () => void; };
//   new <T extends object>(target: T, handler: ProxyHandler<T>): { 
//       'shit': boolean
//   };
// }

// declare var Proxy: ProxyConstructor;

// interface Proxied {
//   [key in PropertyKey]: any;
// }

// interface ProxyHandler<T extends object, K extends PropertyKey> {
//   getPrototypeOf? (target: T): object | null;
//   setPrototypeOf? (target: T, v: any): boolean;
//   isExtensible? (target: T): boolean;
//   preventExtensions? (target: T): boolean;
//   getOwnPropertyDescriptor? (target: T, p: PropertyKey): PropertyDescriptor | undefined;
//   has? (target: T, p: PropertyKey): boolean;
//   get? (target: T, p: K, receiver: any): any;
//   set? (target: T, p: PropertyKey, value: any, receiver: any): boolean;
//   deleteProperty? (target: T, p: PropertyKey): boolean;
//   defineProperty? (target: T, p: PropertyKey, attributes: PropertyDescriptor): boolean;
//   ownKeys? (target: T): PropertyKey[];
//   apply? (target: T, thisArg: any, argArray?: any): any;
//   construct? (target: T, argArray: any, newTarget?: any): object;
// }


// interface ProxyConstructor {
//   revocable<T extends object, K extends PropertyKey>(target: T, handler: ProxyHandler<T, K>): { proxy: T; revoke: () => void; };
//   new <T extends object, K extends PropertyKey>(target: T, handler: ProxyHandler<T, K>): { 
//       [key in K]: handler.get(key)
//   };
// }

// declare var Proxy: ProxyConstructor;

// // function get(t, f: 'a'): 1;
// // function get(t, f: 'b'): true;
// // function get(t, f: 'c'): 'hello';
// // function get(t, f) {
// //   switch (f) {
// //     case 'a': return 1;
// //     case 'b': return true;
// //     case 'c': return 'hello'
// //   }
// // }


// const x = new Proxy({}, {
//   get(t, k: string) {
//     throw new Error('Do not linke!')
//     return 'hi'
//   }
// })

// console.log(x.a)








/**
 * Generates a SHACL form from a nodeshape
 * represented as an LDflex object
 * @param obj LDflex nodeshape object
 */
export function ToShaclForm_prev({shacl}: any) {
  // @ts-ignore
  const [fields, addField] = useReducer((s, a) => {
    return [ ...s, a ]
  }, []);


  // for await (const property of obj.property) {
    
  // }
  useEffect(() => {
    (async () => {
      for await (const property of shacl.property) {
        const f = await property.name;
        console.log(`${f}`)
        addField(property);
      };
      // const node  = await shacl.a;
      // const node2  = await shacl.property;
      // console.log(node);
    })();
  }, [shacl])

  return <form> {fields.map(property => <PropertyField property={property}/>)} </form>
  // for sh:closed and sh:ignoredProperties
}

export function Description(object: any): string {
  const [value, setValue] = useState<string>(object.value as string);
  useEffect(() => {
    (async() => {
      const name = await object.name;
      if (name) setValue(`${name}`);
    })();
  }, [object])
  return value;
};



export function PropertyField({property}: any) {
  return (
    <>
      <label htmlFor={property.value}>{Description(property)}</label>
      <input name={property.value} readOnly={false} required={true} placeholder={property.value}/>
    </>
  )
  
//   (
//   <>
//   <div>
//   <label htmlFor="cc-number">Enter your credit card number</label>
//   <input name="sex" id="sex" autoComplete="on"/>
// </div>
  
//   </>
//   )
}



    // {/* <label htmlFor={property.value}>Person</label>
    // <input name={property.value} readOnly={false} required={true} placeholder={property.value}      />
    // <input name={property.value + "12"} readOnly={false} required={true} placeholder={property.value} autoComplete={"sex"}

// @ts-ignore
export async function PathField({ onChange  }) {

};